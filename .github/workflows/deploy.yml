name: Deploy
on:
  workflow_dispatch:
    inputs:
      tier:
        description: "Deploy environment"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - qa
          - stage
          - prod

permissions:
  id-token: write
  contents: read

jobs:
  Deploy:
    timeout-minutes: 60
    runs-on: ubuntu-latest
    environment: ${{ inputs.tier }}
    env:
      APP: mca-explorer
      TZ: America/New_York
      AWS_REGION: us-east-1
      ECS_CPU_UNITS: 2048
      ECS_MEMORY_UNITS: 4096
      TASK_DEFINITION_TEMPLATE_PATH: .github/aws
      FRONTEND_CONTAINER_PORT: 80
      BACKEND_CONTAINER_PORT: 9000
      TIER: ${{ inputs.tier }}
      IMAGE_TIER: ${{ contains(fromJson('["dev","qa"]'), inputs.tier) && 'development' || 'release' }}
      CICD_ROLE_ARN: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/power-user-github-actions-cicd

    steps:
      - uses: "actions/checkout@v6.0.1"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v5.1.1
        with:
          role-to-assume: ${{ env.CICD_ROLE_ARN }}
          role-session-name: ${{ env.TIER }}-${{ env.APP }}-deploy-${{ github.ref_name }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set dynamic environment variables
        run: |
          echo "DATE=$(date +"%Y%m%d")" >> $GITHUB_ENV

          TIMESTAMP=$(date +"%Y%m%d%H%M%S")
          REPO=${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.$AWS_REGION.amazonaws.com/$APP
          echo "IMAGE_REPOSITORY=$REPO" >> $GITHUB_ENV
          echo "FRONTEND_IMAGE=$REPO:$IMAGE_TIER-frontend-${{ github.ref_name }}-$TIMESTAMP" >> $GITHUB_ENV
          echo "BACKEND_IMAGE=$REPO:$IMAGE_TIER-backend-${{ github.ref_name }}-$TIMESTAMP" >> $GITHUB_ENV
          echo "FRONTEND_IMAGE_LATEST=$REPO:$IMAGE_TIER-frontend-${{ github.ref_name }}-latest" >> $GITHUB_ENV
          echo "BACKEND_IMAGE_LATEST=$REPO:$IMAGE_TIER-backend-${{ github.ref_name }}-latest" >> $GITHUB_ENV
          echo "ENVIRONMENT_TIER=${TIER^^}" >> $GITHUB_ENV

          if [[ "$TIER" == "dev" ]]; then
              echo "LOG_LEVEL=debug" >> $GITHUB_ENV
          else
              echo "LOG_LEVEL=info" >> $GITHUB_ENV
          fi

      - name: Retrieve SSM parameters
        run: |
          PARAMETER_PATH="/analysistools/${TIER}/${APP}"

          # Define parameters to retrieve (SSM name = ENV_VAR_NAME)
          declare -A PARAMS=(
            ["ecs_cluster"]="ECS_CLUSTER"
            ["ecs_web_task"]="ECS_WEB_TASK"
            ["ecs_web_service"]="ECS_WEB_SERVICE"
            ["role_arn"]="ROLE_ARN"
          )

          # Retrieve each parameter and export to environment
          for ssm_name in "${!PARAMS[@]}"; do
            env_var="${PARAMS[$ssm_name]}"
            echo "Retrieving ${PARAMETER_PATH}/${ssm_name} -> ${env_var}"
            value=$(aws ssm get-parameter \
              --name "${PARAMETER_PATH}/${ssm_name}" \
              --with-decryption \
              --query "Parameter.Value" \
              --output text 2>&1) || {
                echo "ERROR: Failed to retrieve parameter: ${PARAMETER_PATH}/${ssm_name}"
                exit 1
              }
            echo "${env_var}=${value}" >> $GITHUB_ENV
            echo "✓ Retrieved ${ssm_name} -> ${env_var}"
          done

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2.0.1
        with:
          mask-password: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3.12.0

      - name: Build and push backend image
        uses: docker/build-push-action@v6.18.0
        with:
          context: .
          file: docker/backend.dockerfile
          pull: true
          push: true
          tags: |
            ${{ env.BACKEND_IMAGE }}
            ${{ env.BACKEND_IMAGE_LATEST }}
          cache-from: type=registry,ref=${{ env.BACKEND_IMAGE_LATEST }}
          cache-to: type=inline

      - name: Build and push frontend image
        uses: docker/build-push-action@v6.18.0
        with:
          context: .
          file: docker/frontend.dockerfile
          pull: true
          push: true
          tags: |
            ${{ env.FRONTEND_IMAGE }}
            ${{ env.FRONTEND_IMAGE_LATEST }}
          cache-from: type=registry,ref=${{ env.FRONTEND_IMAGE_LATEST }}
          cache-to: type=inline

      - name: Render web task definition
        run: |
          envsubst < $TASK_DEFINITION_TEMPLATE_PATH/web.yml > web.yml
          echo "Rendered web Task Definition:"
          cat web.yml

      - name: Register and deploy web service
        run: |
          aws ecs register-task-definition --cli-input-yaml file://web.yml

          aws ecs update-service \
              --cluster ${{ env.ECS_CLUSTER }} \
              --service ${{ env.ECS_WEB_SERVICE }} \
              --task-definition ${{ env.ECS_WEB_TASK }} \
              --desired-count 1 \
              --propagate-tags TASK_DEFINITION \
              --force-new-deployment

      - name: Cleanup old task definitions
        continue-on-error: true
        env:
          AWS_RETRY_MODE: adaptive
          AWS_MAX_ATTEMPTS: 10
        run: |
          set -euo pipefail

          family="$ECS_WEB_TASK"
          echo "Pruning old revisions for family: $family"

          arns=$(aws ecs list-task-definitions --family-prefix "$family" --sort DESC --query 'taskDefinitionArns[3:]' --output text)

          if [[ -z "$arns" || "$arns" == "None" ]]; then
            echo "No old task definitions to prune."
            exit 0
          fi

          echo "$arns" | tr '\t' '\n' | while read -r arn; do
            [[ -z "$arn" ]] && continue

            echo "Deregistering $arn"
            attempt=1
            max_attempts=6
            while true; do
              if aws ecs deregister-task-definition --task-definition "$arn" --no-cli-pager; then
                echo "✓ Deregistered $arn"
                break
              fi

              if (( attempt >= max_attempts )); then
                echo "⚠ Failed to deregister $arn after $attempt attempts; continuing."
                break
              fi

              sleep_seconds=$(( attempt * 3 ))
              echo "Throttled/failed on $arn, retrying in ${sleep_seconds}s (attempt $((attempt + 1))/$max_attempts)..."
              sleep "$sleep_seconds"
              attempt=$(( attempt + 1 ))
            done

            sleep 1
          done